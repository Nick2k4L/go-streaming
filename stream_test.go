package streaming

import (
	"encoding/binary"
	"testing"

	go_i2cp "github.com/go-i2p/go-i2cp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestConnStateString verifies that ConnState.String() returns expected values.
// This is a simple sanity check for the state machine representation.
func TestConnStateString(t *testing.T) {
	tests := []struct {
		state ConnState
		want  string
	}{
		{StateInit, "INIT"},
		{StateSynSent, "SYN_SENT"},
		{StateSynRcvd, "SYN_RCVD"},
		{StateEstablished, "ESTABLISHED"},
		{StateCloseWait, "CLOSE_WAIT"},
		{StateClosing, "CLOSING"},
		{StateClosed, "CLOSED"},
		{ConnState(999), "UNKNOWN"},
	}

	for _, tt := range tests {
		t.Run(tt.want, func(t *testing.T) {
			got := tt.state.String()
			assert.Equal(t, tt.want, got, "ConnState.String()")
		})
	}
}

// TestConstants verifies that protocol constants match I2P streaming spec.
func TestConstants(t *testing.T) {
	tests := []struct {
		name string
		got  int
		want int
	}{
		{"DefaultMTU", DefaultMTU, 1730},
		{"ECIESMTU", ECIESMTU, 1812},
		{"MinMTU", MinMTU, 512},
		{"DefaultWindowSize", DefaultWindowSize, 6},
		{"MaxWindowSize", MaxWindowSize, 128},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, tt.got, tt.name)
		})
	}
}

// TestHashDestination tests the destination hashing function for replay prevention.
func TestHashDestination(t *testing.T) {
	t.Run("valid destination", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.NotNil(t, hash)
		assert.Equal(t, 32, len(hash), "SHA-256 hash should be 32 bytes")

		// Hash should be deterministic
		hash2, err := hashDestination(dest)
		assert.NoError(t, err)
		assert.Equal(t, hash, hash2, "hash should be deterministic")
	})

	t.Run("nil destination", func(t *testing.T) {
		hash, err := hashDestination(nil)
		assert.Error(t, err)
		assert.Nil(t, hash)
		assert.Contains(t, err.Error(), "nil")
	})

	t.Run("different destinations produce different hashes", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest1, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)
		dest2, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash1, err := hashDestination(dest1)
		require.NoError(t, err)
		hash2, err := hashDestination(dest2)
		require.NoError(t, err)

		assert.NotEqual(t, hash1, hash2, "different destinations should have different hashes")
	})

	t.Run("hash can be split into 8 uint32 values", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		// Extract 8 uint32 values (for NACK fields)
		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify we got 8 values
		assert.Equal(t, 8, len(nacks))

		// Verify they're not all zeros (extremely unlikely)
		allZero := true
		for _, nack := range nacks {
			if nack != 0 {
				allZero = false
				break
			}
		}
		assert.False(t, allZero, "hash values should not all be zero")
	})
}

// TestSYNPacketStructure tests that SYN packets have the correct structure
// when generated by sendSYN (without requiring a real I2CP session).
func TestSYNPacketStructure(t *testing.T) {
	// Note: Full sendSYN testing requires a mock I2CP session
	// Here we verify the packet structure that would be generated

	t.Run("SYN packet has required fields", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		// Create a packet as sendSYN would
		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		pkt := &Packet{
			SendStreamID:    123,
			RecvStreamID:    456,
			SequenceNum:     0,
			AckThrough:      0,
			Flags:           FlagSYN | FlagMaxPacketSizeIncluded | FlagSignatureIncluded | FlagFromIncluded,
			MaxPacketSize:   1730,
			NACKs:           nacks,
			FromDestination: dest,
		}

		// Verify packet structure
		assert.Equal(t, uint16(FlagSYN|FlagMaxPacketSizeIncluded|FlagSignatureIncluded|FlagFromIncluded), pkt.Flags)
		assert.Equal(t, 8, len(pkt.NACKs), "SYN should have 8 NACKs for replay prevention")
		assert.NotNil(t, pkt.FromDestination, "SYN should include FROM destination")
		assert.Equal(t, uint16(1730), pkt.MaxPacketSize)

		// Verify packet can be marshaled
		data, err := pkt.Marshal()
		assert.NoError(t, err)
		assert.NotNil(t, data)

		// Verify marshaled packet has reasonable size
		// Header (22) + NACKs (32) + Delay? (0) + MaxPacketSize (2) + FROM (391) + Signature (64) = 511+ bytes
		assert.GreaterOrEqual(t, len(data), 511, "SYN packet with all fields should be at least 511 bytes")
	})

	t.Run("NACK values are from destination hash", func(t *testing.T) {
		crypto := go_i2cp.NewCrypto()
		dest, err := go_i2cp.NewDestination(crypto)
		require.NoError(t, err)

		hash, err := hashDestination(dest)
		require.NoError(t, err)

		nacks := make([]uint32, 8)
		for i := 0; i < 8; i++ {
			nacks[i] = binary.BigEndian.Uint32(hash[i*4 : (i+1)*4])
		}

		// Verify reconstruction
		reconstructed := make([]byte, 32)
		for i, nack := range nacks {
			binary.BigEndian.PutUint32(reconstructed[i*4:(i+1)*4], nack)
		}

		assert.Equal(t, hash, reconstructed, "NACKs should reconstruct to original hash")
	})
}

// Note: I2CP session creation tests require a running I2P router.
// These will be added in Phase 1 when we implement actual I2CP operations.
// For now, we verify that the basic types and constants are correct.
